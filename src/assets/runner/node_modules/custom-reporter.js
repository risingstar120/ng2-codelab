// Do not run async tests in parallel
function TestRunner(){
  this.asyncQueue = [];
  this.promise = null;
}


TestRunner.prototype.processAsyncQueue = function (){
  if (this.asyncQueue.length > 0) {
    console.log('async', this.asyncQueue.length);
    const {test, resolve} = this.asyncQueue.shift();
    let resolved = false;
    const wrapUp = () =>{
      if(!resolved){
        console.log('async end', this.asyncQueue.length);
        window.removeEventListener('error', handleError);
        this.processAsyncQueue();
        resolved = true;
      }

    };

    function handleError(event){
      resolve({pass: false, error: event.error});
      console.log('error');
      wrapUp();
    }

    window.addEventListener('error', handleError);

    test(()=>{
      console.log('pass');
      resolve({pass: true});
      wrapUp();
    });

    window.setTimeout(()=>{
      console.log('timeout');
      resolve({pass: false, error: 'timeout'});
      wrapUp();
    }, 2000);

  }
};
TestRunner.prototype.addAsync = function (test){
  console.log('add async');
  this.asyncQueue.push(test);
};

TestRunner.prototype.runTests = function (tests){
  "use strict";

  const run = () =>{
    console.log('RUNNING SET');
    const result = Promise.all(tests.map((test)=>new Promise((resolve)=>{

      if (test.length === 0) {
        try {
          test();
          resolve({pass: true})
        } catch (error) {
          resolve({pass: false, error: error})
        }

      } else {
        this.addAsync({test, resolve});
      }
    })));
    this.processAsyncQueue();
    return result;
  };


  if(this.promise){
    this.promise = this.promise.then(run);
  } else {
    this.promise = run();
  }
  return this.promise;
};



const testRunner = new TestRunner();
